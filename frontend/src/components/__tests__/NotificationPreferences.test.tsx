import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { vi, expect, test, describe, beforeEach } from 'vitest';\nimport NotificationPreferencesModal from '../NotificationPreferences';\n\n// Mock the hooks and components\nvi.mock('@/hooks/useNotifications', () => ({\n  useNotifications: vi.fn(() => ({\n    preferences: {\n      id: '1',\n      userId: 'user1',\n      emailEnabled: true,\n      inAppEnabled: true,\n      pushEnabled: false,\n      transactionAlerts: true,\n      securityAlerts: true,\n      systemAlerts: true,\n      rewardAlerts: true,\n      adminAlerts: false,\n      withdrawals: true,\n      complianceAlerts: true,\n      auditLogs: false,\n      digestFrequency: 'NONE' as const,\n      createdAt: '2025-01-01',\n      updatedAt: '2025-01-01',\n    },\n    updatePreferences: vi.fn(),\n    loading: false,\n  })),\n}));\n\nvi.mock('../RoleGuard', () => ({\n  default: ({ children, roles }: { children: React.ReactNode; roles: string[] }) => {\n    // Mock role guard to always show content for testing\n    return <div data-testid=\"role-guard\" data-roles={roles.join(',')}>{children}</div>;\n  },\n}));\n\nvi.mock('../LoadingSpinner', () => ({\n  default: ({ size }: { size?: string }) => (\n    <div data-testid=\"loading-spinner\" data-size={size}>Loading...</div>\n  ),\n}));\n\nvi.mock('react-toastify', () => ({\n  toast: {\n    success: vi.fn(),\n    error: vi.fn(),\n  },\n}));\n\ndescribe('NotificationPreferences', () => {\n  const defaultProps = {\n    isOpen: true,\n    onClose: vi.fn(),\n    userId: 'user1',\n  };\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  test('renders modal when open', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    expect(screen.getByText('Notification Preferences')).toBeInTheDocument();\n    expect(screen.getByText('Customize how and when you receive notifications')).toBeInTheDocument();\n  });\n\n  test('does not render when closed', () => {\n    render(<NotificationPreferencesModal {...defaultProps} isOpen={false} />);\n    \n    expect(screen.queryByText('Notification Preferences')).not.toBeInTheDocument();\n  });\n\n  test('displays delivery methods section', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    expect(screen.getByText('Delivery Methods')).toBeInTheDocument();\n    expect(screen.getByText('Email Notifications')).toBeInTheDocument();\n    expect(screen.getByText('In-App Notifications')).toBeInTheDocument();\n    expect(screen.getByText('Push Notifications')).toBeInTheDocument();\n  });\n\n  test('displays notification categories section', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    expect(screen.getByText('Notification Categories')).toBeInTheDocument();\n    expect(screen.getByText('Security Alerts')).toBeInTheDocument();\n    expect(screen.getByText('Transaction Alerts')).toBeInTheDocument();\n    expect(screen.getByText('Rewards & Bonuses')).toBeInTheDocument();\n    expect(screen.getByText('System Notifications')).toBeInTheDocument();\n  });\n\n  test('displays role-restricted categories with labels', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    expect(screen.getByText('Compliance Alerts')).toBeInTheDocument();\n    expect(screen.getByText('ADMIN, AUDITOR only')).toBeInTheDocument();\n    \n    expect(screen.getByText('Audit Log Notifications')).toBeInTheDocument();\n    expect(screen.getByText('ADMIN only')).toBeInTheDocument();\n  });\n\n  test('displays digest frequency options', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    expect(screen.getByText('Email Digest Frequency')).toBeInTheDocument();\n    expect(screen.getByLabelText('Never')).toBeInTheDocument();\n    expect(screen.getByLabelText('daily')).toBeInTheDocument();\n    expect(screen.getByLabelText('weekly')).toBeInTheDocument();\n  });\n\n  test('toggles preferences when clicked', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    const emailToggle = screen.getByRole('checkbox', { name: /email/i });\n    \n    // Initial state should be checked (based on mock data)\n    expect(emailToggle).toBeChecked();\n    \n    // Click to toggle\n    fireEvent.click(emailToggle);\n    \n    // Should now be unchecked\n    expect(emailToggle).not.toBeChecked();\n  });\n\n  test('shows unsaved changes warning', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    // Make a change\n    const emailToggle = screen.getByRole('checkbox', { name: /email/i });\n    fireEvent.click(emailToggle);\n    \n    expect(screen.getByText('You have unsaved changes')).toBeInTheDocument();\n  });\n\n  test('calls onClose when cancel button is clicked', () => {\n    const onClose = vi.fn();\n    render(<NotificationPreferencesModal {...defaultProps} onClose={onClose} />);\n    \n    fireEvent.click(screen.getByText('Cancel'));\n    \n    expect(onClose).toHaveBeenCalled();\n  });\n\n  test('calls onClose when close button (X) is clicked', () => {\n    const onClose = vi.fn();\n    render(<NotificationPreferencesModal {...defaultProps} onClose={onClose} />);\n    \n    fireEvent.click(screen.getByLabelText('Close'));\n    \n    expect(onClose).toHaveBeenCalled();\n  });\n\n  test('shows role guard for save button', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    const roleGuards = screen.getAllByTestId('role-guard');\n    const saveButtonRoleGuard = roleGuards.find(guard => \n      guard.getAttribute('data-roles') === 'ADMIN,AUDITOR'\n    );\n    \n    expect(saveButtonRoleGuard).toBeInTheDocument();\n    expect(saveButtonRoleGuard).toContainElement(screen.getByText('Save Preferences'));\n  });\n\n  test('shows view-only message for restricted users', () => {\n    // Mock RoleGuard to show fallback\n    vi.mocked(require('../RoleGuard').default).mockImplementation(\n      ({ fallback, roles }: { fallback?: React.ReactNode; roles: string[] }) => {\n        if (roles.includes('ADMIN') || roles.includes('AUDITOR')) {\n          return fallback;\n        }\n        return null;\n      }\n    );\n\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    expect(screen.getByText('View-only access')).toBeInTheDocument();\n  });\n\n  test('handles digest frequency changes', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    const weeklyRadio = screen.getByLabelText('weekly');\n    fireEvent.click(weeklyRadio);\n    \n    expect(weeklyRadio).toBeChecked();\n    expect(screen.getByText('You have unsaved changes')).toBeInTheDocument();\n  });\n\n  test('disables save button when no changes', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    const saveButton = screen.getByText('Save Preferences');\n    expect(saveButton).toBeDisabled();\n  });\n\n  test('enables save button when changes are made', () => {\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    // Make a change\n    const emailToggle = screen.getByRole('checkbox', { name: /email/i });\n    fireEvent.click(emailToggle);\n    \n    const saveButton = screen.getByText('Save Preferences');\n    expect(saveButton).not.toBeDisabled();\n  });\n\n  test('shows loading state', () => {\n    const mockUseNotifications = vi.fn(() => ({\n      preferences: null,\n      updatePreferences: vi.fn(),\n      loading: true,\n    }));\n    \n    vi.mocked(require('@/hooks/useNotifications').useNotifications).mockImplementation(\n      mockUseNotifications\n    );\n\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n    expect(screen.getByText('Loading preferences...')).toBeInTheDocument();\n  });\n\n  test('handles save operation', async () => {\n    const updatePreferences = vi.fn().mockResolvedValue({});\n    const onClose = vi.fn();\n    \n    vi.mocked(require('@/hooks/useNotifications').useNotifications).mockImplementation(() => ({\n      preferences: {\n        emailEnabled: true,\n        inAppEnabled: true,\n        pushEnabled: false,\n      },\n      updatePreferences,\n      loading: false,\n    }));\n\n    render(<NotificationPreferencesModal {...defaultProps} onClose={onClose} />);\n    \n    // Make a change\n    const emailToggle = screen.getByRole('checkbox', { name: /email/i });\n    fireEvent.click(emailToggle);\n    \n    // Save\n    const saveButton = screen.getByText('Save Preferences');\n    fireEvent.click(saveButton);\n    \n    await waitFor(() => {\n      expect(updatePreferences).toHaveBeenCalled();\n    });\n  });\n\n  test('handles save errors gracefully', async () => {\n    const updatePreferences = vi.fn().mockRejectedValue(new Error('Save failed'));\n    const toast = require('react-toastify').toast;\n    \n    vi.mocked(require('@/hooks/useNotifications').useNotifications).mockImplementation(() => ({\n      preferences: {\n        emailEnabled: true,\n      },\n      updatePreferences,\n      loading: false,\n    }));\n\n    render(<NotificationPreferencesModal {...defaultProps} />);\n    \n    // Make a change and save\n    const emailToggle = screen.getByRole('checkbox', { name: /email/i });\n    fireEvent.click(emailToggle);\n    \n    const saveButton = screen.getByText('Save Preferences');\n    fireEvent.click(saveButton);\n    \n    await waitFor(() => {\n      expect(toast.error).toHaveBeenCalledWith('Failed to save preferences. Please try again.');\n    });\n  });\n});\n
