/**\n * Complete AI Cybersecurity System Launcher\n * \n * Starts all components of the AI cybersecurity system:\n * - Monitoring Dashboard (React)\n * - Integration Server (Node.js + Socket.IO)\n * - AI Agent with threat analysis\n * - Dashboard connector for real-time data\n */\n\nconst { spawn, exec } = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\nconst CyberAIAgent = require('./CyberAIAgent');\nconst DashboardConnector = require('./integrations/DashboardConnector');\n\nclass SystemLauncher {\n    constructor() {\n        this.processes = new Map();\n        this.aiAgent = null;\n        this.connector = null;\n        this.isShuttingDown = false;\n        \n        // System configuration\n        this.config = {\n            dashboard: {\n                port: 3002,\n                path: path.join(__dirname, '../dashboard'),\n                startCommand: 'npm start'\n            },\n            integrationServer: {\n                port: 8001,\n                path: path.join(__dirname, '../monitoring'),\n                startCommand: 'node integration_server.js'\n            },\n            ai: {\n                agentId: 'cyber-ai-agent-001',\n                autoResponse: true,\n                confidenceThreshold: 0.8\n            }\n        };\n        \n        console.log('üöÄ AI Cybersecurity System Launcher initialized');\n    }\n    \n    /**\n     * Launch the complete system\n     */\n    async launch() {\n        try {\n            console.log('\\nüé¨ Starting AI Cybersecurity System...');\n            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n            \n            // Pre-launch checks\n            await this.performPrelaunchChecks();\n            \n            // Start integration server first\n            await this.startIntegrationServer();\n            \n            // Start dashboard\n            await this.startDashboard();\n            \n            // Initialize AI Agent\n            await this.startAIAgent();\n            \n            // Connect AI to dashboard\n            await this.connectToDashboard();\n            \n            // Setup graceful shutdown\n            this.setupGracefulShutdown();\n            \n            console.log('\\n‚úÖ All systems operational!');\n            console.log('üìä Dashboard: http://localhost:3002');\n            console.log('üì° Integration Server: http://localhost:8001');\n            console.log('ü§ñ AI Agent: Active and monitoring');\n            console.log('\\nüéØ System ready for threat detection and response!');\n            \n            // Start monitoring system health\n            this.startHealthMonitoring();\n            \n            // Simulate some initial threats for demo\n            setTimeout(() => {\n                this.simulateInitialThreats();\n            }, 5000);\n            \n        } catch (error) {\n            console.error('‚ùå System launch failed:', error);\n            await this.shutdown();\n            process.exit(1);\n        }\n    }\n    \n    /**\n     * Perform pre-launch system checks\n     */\n    async performPrelaunchChecks() {\n        console.log('\\nüîç Performing pre-launch checks...');\n        \n        // Check if required directories exist\n        const requiredPaths = [\n            this.config.dashboard.path,\n            this.config.integrationServer.path,\n            __dirname\n        ];\n        \n        for (const pathToCheck of requiredPaths) {\n            if (!fs.existsSync(pathToCheck)) {\n                throw new Error(`Required path not found: ${pathToCheck}`);\n            }\n        }\n        \n        // Check Node.js modules\n        const requiredModules = ['express', 'socket.io', 'cors'];\n        const integrationServerPackageJson = path.join(this.config.integrationServer.path, 'package.json');\n        \n        if (fs.existsSync(integrationServerPackageJson)) {\n            console.log('   ‚úÖ Integration server package.json found');\n        } else {\n            console.log('   ‚ö†Ô∏è Integration server package.json not found - dependencies may need installation');\n        }\n        \n        console.log('   ‚úÖ Pre-launch checks completed');\n    }\n    \n    /**\n     * Start the integration server\n     */\n    async startIntegrationServer() {\n        return new Promise((resolve, reject) => {\n            console.log('\\nüì° Starting Integration Server...');\n            \n            const serverPath = this.config.integrationServer.path;\n            const serverScript = path.join(serverPath, 'integration_server.js');\n            \n            if (!fs.existsSync(serverScript)) {\n                return reject(new Error(`Integration server script not found: ${serverScript}`));\n            }\n            \n            const serverProcess = spawn('node', ['integration_server.js'], {\n                cwd: serverPath,\n                stdio: ['pipe', 'pipe', 'pipe']\n            });\n            \n            let serverStarted = false;\n            \n            serverProcess.stdout.on('data', (data) => {\n                const output = data.toString();\n                console.log(`[Integration Server] ${output.trim()}`);\n                \n                if (output.includes('listening on') || output.includes('Server running')) {\n                    if (!serverStarted) {\n                        serverStarted = true;\n                        console.log('   ‚úÖ Integration Server started successfully');\n                        resolve();\n                    }\n                }\n            });\n            \n            serverProcess.stderr.on('data', (data) => {\n                console.error(`[Integration Server Error] ${data.toString().trim()}`);\n            });\n            \n            serverProcess.on('error', (error) => {\n                if (!serverStarted) {\n                    reject(error);\n                }\n            });\n            \n            serverProcess.on('exit', (code) => {\n                console.log(`Integration Server exited with code ${code}`);\n                this.processes.delete('integrationServer');\n            });\n            \n            this.processes.set('integrationServer', serverProcess);\n            \n            // Timeout fallback\n            setTimeout(() => {\n                if (!serverStarted) {\n                    console.log('   ‚ö†Ô∏è Server startup timeout - assuming success');\n                    resolve();\n                }\n            }, 8000);\n        });\n    }\n    \n    /**\n     * Start the React dashboard\n     */\n    async startDashboard() {\n        return new Promise((resolve, reject) => {\n            console.log('\\nüìä Starting Monitoring Dashboard...');\n            \n            const dashboardPath = this.config.dashboard.path;\n            \n            if (!fs.existsSync(dashboardPath)) {\n                return reject(new Error(`Dashboard path not found: ${dashboardPath}`));\n            }\n            \n            // Check for next.config.js or package.json\n            const hasNextConfig = fs.existsSync(path.join(dashboardPath, 'next.config.js'));\n            const hasPackageJson = fs.existsSync(path.join(dashboardPath, 'package.json'));\n            \n            if (!hasPackageJson) {\n                return reject(new Error('Dashboard package.json not found'));\n            }\n            \n            const dashboardProcess = spawn('npm', ['start'], {\n                cwd: dashboardPath,\n                stdio: ['pipe', 'pipe', 'pipe'],\n                shell: true\n            });\n            \n            let dashboardStarted = false;\n            \n            dashboardProcess.stdout.on('data', (data) => {\n                const output = data.toString();\n                console.log(`[Dashboard] ${output.trim()}`);\n                \n                if (output.includes('ready on') || output.includes('compiled successfully') || output.includes('Local:')) {\n                    if (!dashboardStarted) {\n                        dashboardStarted = true;\n                        console.log('   ‚úÖ Dashboard started successfully');\n                        resolve();\n                    }\n                }\n            });\n            \n            dashboardProcess.stderr.on('data', (data) => {\n                const error = data.toString();\n                console.error(`[Dashboard Error] ${error.trim()}`);\n                \n                // Some React warnings are normal\n                if (!error.includes('Warning:') && !error.includes('Note:')) {\n                    if (!dashboardStarted) {\n                        reject(new Error(`Dashboard startup error: ${error}`));\n                    }\n                }\n            });\n            \n            dashboardProcess.on('error', (error) => {\n                if (!dashboardStarted) {\n                    reject(error);\n                }\n            });\n            \n            dashboardProcess.on('exit', (code) => {\n                console.log(`Dashboard exited with code ${code}`);\n                this.processes.delete('dashboard');\n            });\n            \n            this.processes.set('dashboard', dashboardProcess);\n            \n            // Extended timeout for dashboard startup\n            setTimeout(() => {\n                if (!dashboardStarted) {\n                    console.log('   ‚ö†Ô∏è Dashboard startup timeout - assuming success');\n                    resolve();\n                }\n            }, 15000);\n        });\n    }\n    \n    /**\n     * Start the AI Agent\n     */\n    async startAIAgent() {\n        console.log('\\nü§ñ Initializing AI Agent...');\n        \n        try {\n            this.aiAgent = new CyberAIAgent(this.config.ai);\n            \n            // Set up agent event listeners\n            this.setupAIAgentListeners();\n            \n            // Initialize the agent\n            await this.aiAgent.initialize();\n            \n            console.log('   ‚úÖ AI Agent initialized and ready');\n            \n        } catch (error) {\n            throw new Error(`AI Agent initialization failed: ${error.message}`);\n        }\n    }\n    \n    /**\n     * Connect AI Agent to Dashboard\n     */\n    async connectToDashboard() {\n        console.log('\\nüîó Connecting AI Agent to Dashboard...');\n        \n        try {\n            this.connector = new DashboardConnector({\n                integrationServerPort: this.config.integrationServer.port,\n                dashboardPort: this.config.dashboard.port\n            });\n            \n            // Set up connector event listeners\n            this.setupConnectorListeners();\n            \n            // Connect to dashboard\n            await this.connector.connect(this.aiAgent);\n            \n            console.log('   ‚úÖ AI Agent connected to dashboard');\n            \n        } catch (error) {\n            console.error(`   ‚ö†Ô∏è Dashboard connection failed: ${error.message}`);\n            console.log('   üîÑ AI Agent will continue running without dashboard integration');\n        }\n    }\n    \n    /**\n     * Set up AI Agent event listeners\n     */\n    setupAIAgentListeners() {\n        if (!this.aiAgent) return;\n        \n        this.aiAgent.on('agent-ready', (data) => {\n            console.log(`ü§ñ AI Agent Ready: ${data.agentId}`);\n        });\n        \n        this.aiAgent.on('threat-analyzed', (analysis) => {\n            const severity = this.getSeverityEmoji(analysis.riskScore);\n            console.log(`${severity} Threat Analyzed: ${analysis.analysisId} (Risk: ${analysis.riskScore.toFixed(3)})`);\n        });\n        \n        this.aiAgent.on('action-executed', (action) => {\n            console.log(`üõ°Ô∏è Action Executed: ${action.action.action}`);\n        });\n    }\n    \n    /**\n     * Set up Dashboard Connector event listeners\n     */\n    setupConnectorListeners() {\n        if (!this.connector) return;\n        \n        this.connector.on('connector-ready', () => {\n            console.log('üîó Dashboard Connector ready');\n        });\n        \n        this.connector.on('dashboard-connected', () => {\n            console.log('üì° Dashboard connection established');\n        });\n        \n        this.connector.on('dashboard-disconnected', (reason) => {\n            console.log(`üì° Dashboard disconnected: ${reason}`);\n        });\n        \n        this.connector.on('connector-error', (error) => {\n            console.error(`üîó Connector error: ${error.message}`);\n        });\n    }\n    \n    /**\n     * Start system health monitoring\n     */\n    startHealthMonitoring() {\n        console.log('\\nüíì Starting system health monitoring...');\n        \n        setInterval(() => {\n            this.performHealthCheck();\n        }, 30000); // Every 30 seconds\n    }\n    \n    /**\n     * Perform system health check\n     */\n    performHealthCheck() {\n        const health = {\n            timestamp: new Date(),\n            processes: {},\n            ai: {},\n            connector: {}\n        };\n        \n        // Check processes\n        for (const [name, process] of this.processes) {\n            health.processes[name] = {\n                running: process && !process.killed,\n                pid: process?.pid\n            };\n        }\n        \n        // Check AI Agent\n        if (this.aiAgent) {\n            const status = this.aiAgent.getStatus();\n            health.ai = {\n                status: status.status,\n                threatsAnalyzed: status.metrics.threatsAnalyzed,\n                uptime: status.uptime\n            };\n        }\n        \n        // Check connector\n        if (this.connector) {\n            const stats = this.connector.getStatistics();\n            health.connector = {\n                connected: stats.isConnected,\n                threatsSent: stats.threatsSent,\n                errors: stats.errors.length\n            };\n        }\n        \n        // Log health summary\n        const processCount = Object.values(health.processes).filter(p => p.running).length;\n        const aiStatus = health.ai.status || 'unknown';\n        const connectorStatus = health.connector.connected ? 'connected' : 'disconnected';\n        \n        console.log(`üíì Health: Processes(${processCount}/${this.processes.size}) AI(${aiStatus}) Connector(${connectorStatus})`);\n    }\n    \n    /**\n     * Simulate initial threats for demonstration\n     */\n    async simulateInitialThreats() {\n        if (!this.aiAgent) return;\n        \n        console.log('\\nüé≠ Simulating initial threats for demonstration...');\n        \n        const threats = [\n            {\n                source: 'network_ids',\n                type: 'port_scan',\n                sourceIP: '203.0.113.25',\n                targetPorts: [22, 80, 443, 3389],\n                timestamp: new Date(),\n                indicators: ['reconnaissance', 'port_scanning'],\n                severity: 'medium'\n            },\n            {\n                source: 'web_application',\n                type: 'sql_injection',\n                url: '/admin/login.php',\n                payload: \"' OR 1=1; DROP TABLE users; --\",\n                sourceIP: '192.0.2.100',\n                timestamp: new Date(),\n                indicators: ['sql_injection', 'malicious_payload'],\n                severity: 'high'\n            },\n            {\n                source: 'endpoint_security',\n                type: 'malware_detection',\n                fileName: 'important_document.pdf.exe',\n                fileHash: 'a1b2c3d4e5f67890123456789012345678901234',\n                sourceIP: '198.51.100.75',\n                timestamp: new Date(),\n                indicators: ['malware', 'suspicious_executable', 'double_extension'],\n                severity: 'critical'\n            }\n        ];\n        \n        for (let i = 0; i < threats.length; i++) {\n            setTimeout(async () => {\n                try {\n                    await this.aiAgent.analyzeThreat(threats[i]);\n                } catch (error) {\n                    console.error('Simulation error:', error);\n                }\n            }, i * 3000); // 3 seconds apart\n        }\n    }\n    \n    /**\n     * Get severity emoji\n     */\n    getSeverityEmoji(riskScore) {\n        if (riskScore >= 0.9) return 'üö®';\n        if (riskScore >= 0.7) return '‚ö†Ô∏è';\n        if (riskScore >= 0.5) return 'üî∂';\n        if (riskScore >= 0.3) return 'üî∏';\n        return '‚ÑπÔ∏è';\n    }\n    \n    /**\n     * Set up graceful shutdown handlers\n     */\n    setupGracefulShutdown() {\n        const signals = ['SIGTERM', 'SIGINT', 'SIGUSR1', 'SIGUSR2'];\n        \n        signals.forEach(signal => {\n            process.on(signal, () => {\n                console.log(`\\nüîÑ Received ${signal}, shutting down gracefully...`);\n                this.shutdown();\n            });\n        });\n        \n        process.on('exit', () => {\n            console.log('üëã System shutdown complete');\n        });\n    }\n    \n    /**\n     * Shutdown all system components\n     */\n    async shutdown() {\n        if (this.isShuttingDown) return;\n        this.isShuttingDown = true;\n        \n        console.log('\\nüõë Shutting down AI Cybersecurity System...');\n        \n        try {\n            // Disconnect dashboard connector\n            if (this.connector) {\n                console.log('üîó Disconnecting dashboard connector...');\n                await this.connector.disconnect();\n            }\n            \n            // Shutdown AI Agent\n            if (this.aiAgent) {\n                console.log('ü§ñ Shutting down AI Agent...');\n                await this.aiAgent.shutdown();\n            }\n            \n            // Kill all processes\n            console.log('‚ö° Terminating processes...');\n            for (const [name, process] of this.processes) {\n                if (process && !process.killed) {\n                    console.log(`   Stopping ${name}...`);\n                    process.kill('SIGTERM');\n                    \n                    // Force kill after timeout\n                    setTimeout(() => {\n                        if (!process.killed) {\n                            process.kill('SIGKILL');\n                        }\n                    }, 5000);\n                }\n            }\n            \n            console.log('‚úÖ Shutdown complete');\n            \n        } catch (error) {\n            console.error('‚ùå Shutdown error:', error);\n        }\n        \n        setTimeout(() => {\n            process.exit(0);\n        }, 3000);\n    }\n    \n    /**\n     * Get system status\n     */\n    getSystemStatus() {\n        return {\n            processes: Object.fromEntries(\n                Array.from(this.processes.entries()).map(([name, process]) => [\n                    name,\n                    {\n                        running: process && !process.killed,\n                        pid: process?.pid\n                    }\n                ])\n            ),\n            aiAgent: this.aiAgent ? this.aiAgent.getStatus() : null,\n            connector: this.connector ? this.connector.getStatistics() : null,\n            uptime: process.uptime() * 1000\n        };\n    }\n}\n\n/**\n * Launch the complete system\n */\nasync function main() {\n    const launcher = new SystemLauncher();\n    \n    try {\n        await launcher.launch();\n    } catch (error) {\n        console.error('‚ùå System launch failed:', error);\n        process.exit(1);\n    }\n}\n\n// Only run if this is the main module\nif (require.main === module) {\n    main();\n}\n\nmodule.exports = SystemLauncher;
